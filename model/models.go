// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type BooleanExpression struct {
	// Equals value
	Eq *bool `json:"_eq"`
	// Is value null (true) or not null (false)
	IsNull *bool `json:"_is_null"`
	// Does not equal value
	Neq *bool `json:"_neq"`
}

type CreateUserForm struct {
	Email    *string `json:"email"`
	Phone    *string `json:"phone"`
	Password *string `json:"password"`
	Name     *string `json:"name"`
	Avatar   *string `json:"avatar"`
	Confirm  *bool   `json:"confirm"`
	Data     Object  `json:"data"`
}

type FloatExpression struct {
	// Equals value
	Eq *float64 `json:"_eq"`
	// Does not equal value
	Neq *float64 `json:"_neq"`
	// Is greater than value
	Gt *float64 `json:"_gt"`
	// Is greater than or equals value
	Gte *float64 `json:"_gte"`
	// Is value null (true) or not null (false)
	IsNull *bool `json:"_is_null"`
	// Is lesser than value
	Lt *float64 `json:"_lt"`
	// Is lesser than or equals value
	Lte *float64 `json:"_lte"`
}

type IntExpression struct {
	// Equals value
	Eq *int `json:"_eq"`
	// Does not equal value
	Neq *int `json:"_neq"`
	// Is greater than value
	Gt *int `json:"_gt"`
	// Is greater than or equals value
	Gte *int `json:"_gte"`
	// Is value null (true) or not null (false)
	IsNull *bool `json:"_is_null"`
	// Is lesser than value
	Lt *int `json:"_lt"`
	// Is lesser than or equals value
	Lte *int `json:"_lte"`
}

type LoginResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	ID           string `json:"id"`
}

type SignupForm struct {
	Name     *string `json:"name"`
	Avatar   *string `json:"avatar"`
	Email    *string `json:"email"`
	Phone    *string `json:"phone"`
	Password string  `json:"password"`
	Data     Object  `json:"data"`
}

type StringExpression struct {
	// Equals value
	Eq *string `json:"_eq"`
	// Does not equal value
	Neq *string `json:"_neq"`
	// Is greater than value
	Gt *string `json:"_gt"`
	// Is greater than or equals value
	Gte *string `json:"_gte"`
	// Value matching pattern where '%' represents zero or more characters and '_' represents a single character. Eg. '_r%' finds values having 'r' in second position
	Like *string `json:"_like"`
	// Value matching (case-insensitive) pattern where '%' represents zero or more characters and '_' represents a single character. Eg. '_r%' finds values having 'r' in second position
	Ilike *string `json:"_ilike"`
	// Value not matching pattern where '%' represents zero or more characters and '_' represents a single character. Eg. '_r%' finds values not having 'r' in second position
	Nlike *string `json:"_nlike"`
	// Value not matching (case-insensitive) pattern where '%' represents zero or more characters and '_' represents a single character. Eg. '_r%' finds values not having 'r' in second position
	Nilike *string `json:"_nilike"`
	// Is value null (true) or not null (false)
	IsNull *bool `json:"_is_null"`
	// Is lesser than value
	Lt *string `json:"_lt"`
	// Is lesser than or equals value
	Lte *string `json:"_lte"`
}

type TimeExpression struct {
	// Equals value
	Eq *string `json:"_eq"`
	// Does not equal value
	Neq *string `json:"_neq"`
	// Is greater than value
	Gt *string `json:"_gt"`
	// Is greater than or equals value
	Gte *string `json:"_gte"`
	// Is value null (true) or not null (false)
	IsNull *bool `json:"_is_null"`
	// Is lesser than value
	Lt *string `json:"_lt"`
	// Is lesser than or equals value
	Lte *string `json:"_lte"`
}

type OrderDirection string

const (
	// Ascending
	OrderDirectionAsc OrderDirection = "asc"
	// Descending
	OrderDirectionDesc OrderDirection = "desc"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_direction", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
